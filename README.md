# CustomAuth - NextJS + Backend Authentication Library

**⚠️ Generated with AI - Use at your own risk**

This authentication library was generated with AI and is provided as-is. While it can be used in your projects, you are responsible for:
- Testing thoroughly in your environment
- Security audits and vulnerability checks
- Compliance with your project requirements
- Maintenance and updates

## About This Library

A frontend authentication library for NextJS applications with clear separation between Frontend and Backend. Provides a pattern for integrating with backend authentication APIs.

**Generated by:** AI (Claude Haiku)  
**Purpose:** Reference implementation for NextJS + Backend auth pattern  

## What It Includes

- Session management with configurable refresh intervals
- Token storage using cookies or localStorage
- Automatic token refresh on expiration
- NextAuth-like hooks and components
- NextJS middleware for route protection
- TypeScript support with full types

## Installation

```bash
npm install custom-auth
# or
yarn add custom-auth
```

## Quick Start

### 1. Initialize CustomAuth in your app

Create a configuration file (e.g., `lib/auth.ts`):

```typescript
import { CustomAuth } from 'custom-auth';

CustomAuth({
    endpoints: {
        auth: `/auth/signin`,        // Backend login endpoint
        refresh: `/auth/refresh`,    // Backend token refresh endpoint
        session: `/auth/session`     // Backend get session/user data endpoint
    },
    token: {
        name: {
            accessToken: 'access_token',
            refreshToken: 'refresh_token'
        }
    },
    session: {
        interval: 5000,                  // Refresh session every 5 seconds
        strategy: 'cookie'               // 'cookie' or 'localStorage'
    },
    pages: {
        signIn: '/signin'
    }
});
```

**Note:** This library is designed for **Frontend only**. Your backend API must handle authentication and provide the endpoints above.

### 2. Wrap your app with AuthProvider

In your `_app.tsx` or `layout.tsx`:

```typescript
import { AuthProvider } from 'custom-auth';

export default function App({ Component, pageProps }) {
    return (
        <AuthProvider baseUrl="http://localhost:3000">
            <Component {...pageProps} />
        </AuthProvider>
    );
}
```

### 3. Use authentication in your components

```typescript
import { useAuth, useSession } from 'custom-auth';

export default function Dashboard() {
    const { session, status, isLoading } = useSession();
    const { signOut, isAuthenticated } = useAuth();

    if (isLoading) {
        return <div>Loading...</div>;
    }

    if (!isAuthenticated) {
        return <div>Not authenticated</div>;
    }

    return (
        <div>
            <h1>Welcome, {session?.user?.name}</h1>
            <pre>{JSON.stringify(session, null, 2)}</pre>
            <button onClick={signOut}>Sign Out</button>
        </div>
    );
}
```

## API Reference

### Configuration Object

```typescript
interface AuthConfig {
    endpoints: {
        auth: string;       // POST endpoint for login
        refresh: string;    // POST endpoint for token refresh
        session: string;    // GET endpoint for user session
    };
    token?: {
        name: {
            accessToken?: string;    // Default: 'access_token'
            refreshToken?: string;   // Default: 'refresh_token'
        };
    };
    session?: {
        interval: number;            // Default: 5000ms
        strategy: 'cookie' | 'localStorage';  // Default: 'cookie'
    };
    pages: {
        signIn: string;              // Redirect URL when not authenticated
        signUp?: string;
    };
}
```

### Hooks

#### `useAuth()`

Returns authentication state and methods:

```typescript
const {
    session,           // User session data
    isLoading,        // Loading state
    isAuthenticated,  // Boolean authentication status
    error,            // Error message if any
    signIn,           // Function to sign in
    signOut,          // Function to sign out
    token             // Token information
} = useAuth();
```

#### `useSession()`

Returns session-specific data:

```typescript
const {
    data,       // User session data
    status,     // 'authenticated' | 'unauthenticated' | 'loading'
    isLoading,  // Boolean loading state
    session     // User session (same as data)
} = useSession();
```

#### Session Type Augmentation (NextAuth-style)

You can extend the `Session` type in your app via module augmentation:

```typescript
// types/custom-auth.d.ts
import 'custom-auth';

declare module 'custom-auth' {
    interface Session {
        user?: {
            id?: string;
            role?: 'admin' | 'user';
            address?: string;
        };
    }
}
```

Make sure your `tsconfig.json` includes the `types/` folder:

```json
{
  "include": ["types/**/*.d.ts", "src/**/*"]
}
```

### Utility Functions

#### `getAccessToken()`
Returns the current access token or null

#### `getRefreshToken()`
Returns the current refresh token or null

#### `getSession()`
Returns the current user session

#### `isAuthenticated()`
Returns whether the user is authenticated

#### `isAccessTokenExpired()`
Returns whether the access token is expired

#### `refreshAccessToken()`
Manually refresh the access token

#### `getTokenInfo()`
Returns token information including expiration

#### `decodeToken(token)`
Decodes a JWT token (without verification)

#### `getTokenClaims()`
Decodes and returns the current token's claims

#### `willTokenExpireSoon(minutesBeforeExpiry)`
Checks if token will expire within specified minutes (default: 5)

#### `clearAuth()`
Clears all authentication data

### Components

#### `<AuthProvider />`

Wraps your application to provide authentication state.

Props:
- `baseUrl` - Backend API base URL
- `onSessionExpired` - Callback when session expires

```typescript
<AuthProvider baseUrl="http://api.example.com">
    <YourApp />
</AuthProvider>
```

## Backend API Requirements

This library expects your **separate backend server** to provide these endpoints:

### Sign In Endpoint

**POST** `{BACKEND_API_URL}/auth/signin`

Request:
```json
{
    "email": "user@example.com",
    "password": "password123"
}
```

Response:
```json
{
    "success": true,
    "accessToken": "eyJhbGciOiJIUzI1NiIs...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIs...",
    "expiresIn": 3600
}
```

### Token Refresh Endpoint

**POST** `{BACKEND_API_URL}/auth/refresh`

Request:
```json
{
    "refreshToken": "eyJhbGciOiJIUzI1NiIs..."
}
```

Response:
```json
{
    "accessToken": "eyJhbGciOiJIUzI1NiIs...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIs...",
    "expiresIn": 3600
}
```

### Session Endpoint

**GET** `{BACKEND_API_URL}/auth/session`

Headers:
```
Authorization: Bearer <accessToken>
```

Response:
```json
{
    "user": {
        "id": "123",
        "name": "John Doe",
        "email": "john@example.com",
        "image": "https://..."
    },
    "expires": "2024-02-12T10:30:00Z"
}
```

## NextJS Middleware

Use the built-in middleware to protect your frontend routes:

### Create `middleware.ts`

```typescript
import { authMiddleware } from 'custom-auth';

export const middleware = authMiddleware({
    protectedRoutes: ['/dashboard', '/profile', '/settings'],
    publicRoutes: ['/signin', '/signup', '/'],
});

export const config = {
    matcher: ['/((?!_next/static|_next/image|favicon.ico).*)'],
};
```

**How it works:**
- Requests to protected routes without a valid token are redirected to signin page
- Request headers include decoded user data in `X-User-Data` header
- Public routes are always accessible

## How It Works

### Session Refresh Flow

1. **Initialization** - AuthProvider initializes SessionManager
2. **Auto Refresh** - SessionManager refreshes session every 5 seconds (configurable)
3. **Token Validation** - Before each request, checks if token is expired
4. **Auto Refresh Token** - If token is expired, automatically refreshes it
5. **Session Update** - Updates session data and notifies listeners

### Token Refresh Flow

1. **Access Token Expires** - Token expiration time is tracked
2. **Auto Refresh Attempt** - When expired, automatically calls refresh endpoint
3. **Token Update** - New access token is stored and used
4. **Session Continues** - User session continues without interruption

## Examples

### Sign In Example

```typescript
import { useAuth } from 'custom-auth';
import { useState } from 'react';

export default function SignInForm() {
    const { signIn, error, isLoading } = useAuth();
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');

    const handleSubmit = async (e) => {
        e.preventDefault();
        const success = await signIn({ email, password });
        if (success) {
            // Redirect or update UI
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                placeholder="Email"
            />
            <input
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                placeholder="Password"
            />
            <button type="submit" disabled={isLoading}>
                {isLoading ? 'Signing in...' : 'Sign In'}
            </button>
            {error && <p style={{ color: 'red' }}>{error}</p>}
        </form>
    );
}
```

### Protected Page Example

**Option 1: Middleware-only (Recommended)**

Middleware already protects the route, so you don't need client-side checks:

```typescript
import { useAuth } from 'custom-auth';

export default function ProtectedPage() {
    const { session, isLoading } = useAuth();

    if (isLoading) {
        return <div>Loading...</div>;
    }

    return (
        <div>
            <h1>Welcome, {session?.user?.name}</h1>
            {/* Page content */}
        </div>
    );
}
```

**Option 2: Middleware + Client-side Check (Extra Safety)**

For better UX or additional validation:

```typescript
import { useAuth } from 'custom-auth';
import { useRouter } from 'next/router';
import { useEffect } from 'react';

export default function ProtectedPage() {
    const { isAuthenticated, isLoading } = useAuth();
    const router = useRouter();

    useEffect(() => {
        // Additional client-side check
        // This is optional - middleware already protects this route
        if (!isLoading && !isAuthenticated) {
            router.push('/signin');
        }
    }, [isAuthenticated, isLoading]);

    if (isLoading) {
        return <div>Loading...</div>;
    }

    return <div>This is a protected page</div>;
}
```

**Which should you use?**
- ✅ **Option 1** - Simpler, middleware handles protection
- ✅ **Option 2** - Better UX during loading, additional client-side validation

## Default Values

- **Session Interval**: 5000ms (5 seconds)
- **Token Storage Strategy**: cookie
- **Access Token Name**: access_token
- **Refresh Token Name**: refresh_token
- **Sign In Page**: /signin

## Important Disclaimer

This library was **generated with AI**. Before using in production:

1. **Review the code** - Understand what it does
2. **Security audit** - Check for vulnerabilities
3. **Test thoroughly** - Ensure it works for your use case
4. **No warranty** - Use at your own risk
5. **Your responsibility** - You are responsible for any issues

## License

ISC
